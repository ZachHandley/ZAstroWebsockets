diff --git a/packages/integrations/node/package.json b/packages/integrations/node/package.json
index 39a993467..af3d3d5fc 100644
--- a/packages/integrations/node/package.json
+++ b/packages/integrations/node/package.json
@@ -35,7 +35,8 @@
   "dependencies": {
     "@astrojs/internal-helpers": "workspace:*",
     "send": "^1.2.0",
-    "server-destroy": "^1.0.1"
+    "server-destroy": "^1.0.1",
+    "ws": "^8.18.0"
   },
   "peerDependencies": {
     "astro": "^5.3.0"
@@ -44,6 +45,7 @@
     "@types/node": "^22.10.6",
     "@types/send": "^0.17.4",
     "@types/server-destroy": "^1.0.4",
+    "@types/ws": "^8.5.12",
     "astro": "workspace:*",
     "astro-scripts": "workspace:*",
     "cheerio": "1.0.0",
diff --git a/packages/integrations/node/src/index.ts b/packages/integrations/node/src/index.ts
index 123456789..987654321 100644
--- a/packages/integrations/node/src/index.ts
+++ b/packages/integrations/node/src/index.ts
@@ -1,5 +1,5 @@
 import { fileURLToPath } from 'node:url';
-import { writeJson } from '@astrojs/internal-helpers/fs';
+import { writeJson } from '@astrojs/internal-helpers/fs';
 import type {
 	AstroAdapter,
 	AstroConfig,
diff --git a/packages/integrations/node/src/serve-app.ts b/packages/integrations/node/src/serve-app.ts
index 72b4e0fd6..7c397de6b 100644
--- a/packages/integrations/node/src/serve-app.ts
+++ b/packages/integrations/node/src/serve-app.ts
@@ -20,7 +20,7 @@ export function createAppHandler(app: NodeApp): RequestHandler {
 		console.error(reason);
 	});
 
-	return async (req, res, next, locals) => {
+	return async (req, res, next, locals = {}) => {
 		let request: Request;
 		try {
 			request = NodeApp.createRequest(req);
@@ -31,7 +31,19 @@ export function createAppHandler(app: NodeApp): RequestHandler {
 			res.end('Internal Server Error');
 			return;
 		}
-
+		/**
+		 * An upgrade request will be handled by a listener attached to the `upgrade` event,
+		 * which is the returned function from createWebsocketHandler().
+		 *
+		 * The fact that a request is being handled by this function, a listener for the
+		 * `request` event, means that the request was not an upgrade request.
+		 */
+		Object.assign(locals, {
+			isUpgradeRequest: false,
+			upgradeWebSocket() {
+				throw new Error("The request must be an upgrade request to upgrade the connection to a WebSocket.")
+			}
+		})
 		const routeData = app.match(request);
 		if (routeData) {
 			const response = await als.run(request.url, () =>
diff --git a/packages/integrations/node/src/standalone.ts b/packages/integrations/node/src/standalone.ts
index 8ef4227a1..74f00e778 100644
--- a/packages/integrations/node/src/standalone.ts
+++ b/packages/integrations/node/src/standalone.ts
@@ -7,6 +7,7 @@ import enableDestroy from 'server-destroy';
 import { logListeningOn } from './log-listening-on.js';
 import { createAppHandler } from './serve-app.js';
 import { createStaticHandler } from './serve-static.js';
+import { createWebsocketHandler } from "./websocket/serve-websocket.js";
 import type { Options } from './types.js';
 
 // Used to get Host Value at Runtime
@@ -22,6 +23,8 @@ export default function standalone(app: NodeApp, options: Options) {
 	const host = process.env.HOST ?? hostOptions(options.host);
 	const handler = createStandaloneHandler(app, options);
 	const server = createServer(handler, host, port);
+	// Add WebSocket upgrade handler
+	server.server.on("upgrade", createWebsocketHandler(app))
 	server.server.listen(port, host);
 	if (process.env.ASTRO_NODE_LOGGING !== 'disabled') {
 		logListeningOn(app.getAdapterLogger(), server.server, host);
diff --git a/packages/integrations/node/src/types.ts b/packages/integrations/node/src/types.ts
index 4dae92243..33017d6a7 100644
--- a/packages/integrations/node/src/types.ts
+++ b/packages/integrations/node/src/types.ts
@@ -34,9 +34,9 @@ export interface Options extends UserOptions {
 }
 
 export type RequestHandler = (...args: RequestHandlerParams) => void | Promise<void>;
-type RequestHandlerParams = [
+export type RequestHandlerParams = [
 	req: IncomingMessage,
 	res: ServerResponse,
 	next?: (err?: unknown) => void,
-	locals?: object,
+	locals?: { [key: string]: any },
 ];
diff --git a/packages/integrations/node/src/websocket/attach.ts b/packages/integrations/node/src/websocket/attach.ts
new file mode 100644
index 000000000..13f601edb
--- /dev/null
+++ b/packages/integrations/node/src/websocket/attach.ts
@@ -0,0 +1,22 @@
+import type * as ws from "ws"
+import type { WebSocket } from "./websocket.js"
+
+// WeakMap to store private WebSocket instances
+const wsMap = new WeakMap<WebSocket, ws.WebSocket>()
+
+// Hidden attachment function
+const attacher: { attach: null | typeof attachImpl } = { attach: null }
+
+function attachImpl(standard: WebSocket, ws: ws.WebSocket): void {
+    if (wsMap.has(standard)) {
+        throw new Error("WebSocket already attached")
+    }
+    wsMap.set(standard, ws)
+}
+
+// Initialize the attacher
+attacher.attach = attachImpl
+
+export function attach(standard: WebSocket, ws: ws.WebSocket): void {
+    return attacher.attach?.(standard, ws)
+}
\ No newline at end of file
diff --git a/packages/integrations/node/src/websocket/dev-middleware.ts b/packages/integrations/node/src/websocket/dev-middleware.ts
new file mode 100644
index 000000000..8e2546bc8
--- /dev/null
+++ b/packages/integrations/node/src/websocket/dev-middleware.ts
@@ -0,0 +1,141 @@
+import { AsyncLocalStorage } from 'node:async_hooks'
+import * as ws from 'ws'
+
+// Type definitions for Vite dev server
+export interface ViteDevServer {
+  httpServer: import('node:http').Server
+  middlewares: {
+    stack: Array<{
+      handle: any
+    }>
+  }
+}
+
+// Type for Astro dev handler
+type AstroDevHandler = (
+  req: import('node:http').IncomingMessage,
+  res: import('node:http').ServerResponse,
+) => void
+
+// Global storage for upgrade requests
+const upgradeRequestStorage = new AsyncLocalStorage<[
+  wsServer: ws.WebSocketServer,
+  req: import('node:http').IncomingMessage,
+  socket: import('node:stream').Duplex,
+  head: Buffer
+]>()
+
+/**
+ * Development middleware for handling WebSocket upgrade requests
+ */
+export const onRequest = async function websocketDevMiddleware(
+  context: any,
+  next: () => Promise<Response>
+): Promise<Response> {
+  const upgradeRequest = upgradeRequestStorage.getStore()
+
+  // Non-upgrade request handling
+  if (upgradeRequest === undefined) {
+    // Check if this is a WebSocket upgrade request
+    const isUpgradeRequest = context.request.headers.get('upgrade') === 'websocket'
+
+    // Set up locals for non-upgrade requests
+    context.locals.isUpgradeRequest = isUpgradeRequest
+    context.locals.upgradeWebSocket = () => {
+      throw new Error('The request must be an upgrade request to upgrade the connection to a WebSocket.')
+    }
+
+    return next()
+  }
+
+  // This is an upgrade request - the actual handling happens in the upgrade event handler
+  return new Response(null, { status: 101 })
+}
+
+/**
+ * Set up WebSocket upgrade handling for Vite dev server
+ */
+export function handleUpgradeRequests(viteDevServer: ViteDevServer): void {
+  // Find the Astro dev handler in the middleware stack
+  const astroDevHandler = viteDevServer.middlewares.stack
+    .find((stackItem: any) =>
+      'name' in stackItem.handle && stackItem.handle.name === 'astroDevHandler'
+    )?.handle as AstroDevHandler
+
+  if (!astroDevHandler) {
+    console.warn('[node-websocket] Astro dev handler not found in Vite middleware stack')
+    return
+  }
+
+  // Create WebSocket server with noServer option
+  const wsServer = new ws.WebSocketServer({
+    noServer: true,
+    perMessageDeflate: false,
+    maxPayload: 64 * 1024 * 1024, // 64MB max payload
+  })
+
+  // Handle server lifecycle
+  wsServer.on('error', (error) => {
+    console.error('[node-websocket] WebSocket server error:', error)
+  })
+
+  // Get the HTTP server instance
+  const httpServer = viteDevServer.httpServer
+
+  if (!httpServer) {
+    console.warn('[node-websocket] No HTTP server found, WebSocket upgrade handling may not work')
+    return
+  }
+
+  // Set up upgrade event handler
+  httpServer.on('upgrade', (req, socket, head) => {
+    // Skip Vite HMR WebSocket connections
+    if (req.headers['sec-websocket-protocol'] === 'vite-hmr') {
+      return
+    }
+
+    // Run the upgrade request through AsyncLocalStorage
+    upgradeRequestStorage.run(
+      [wsServer, req, socket, head],
+      () => {
+        // Create a fake response object for the Astro handler
+        const fakeResponse = createFakeResponse()
+
+        // Call the Astro dev handler
+        astroDevHandler(req, fakeResponse)
+      }
+    )
+  })
+
+  // Clean up on server close
+  httpServer.on('close', () => {
+    wsServer.close()
+  })
+}
+
+/**
+ * Create a fake HTTP response object for upgrade handling
+ */
+function createFakeResponse(): import('node:http').ServerResponse {
+  return {
+    setHeader() {},
+    write() {},
+    writeHead() {},
+    end() {},
+    on() {},
+    once() {},
+    emit() { return false },
+    removeListener() { return this },
+    removeAllListeners() { return this },
+    getMaxListeners() { return 0 },
+    listenerCount() { return 0 },
+    listeners() { return [] },
+    rawListeners() { return [] },
+    addListener() { return this },
+    prependListener() { return this },
+    prependOnceListener() { return this },
+    headersSent: false,
+    statusCode: 200,
+    statusMessage: 'OK',
+  } as any as import('node:http').ServerResponse
+}
\ No newline at end of file
diff --git a/packages/integrations/node/src/websocket/response.ts b/packages/integrations/node/src/websocket/response.ts
new file mode 100644
index 000000000..e37080edd
--- /dev/null
+++ b/packages/integrations/node/src/websocket/response.ts
@@ -0,0 +1,32 @@
+import { pipeline } from "node:stream/promises"
+
+export class UpgradeResponse extends Response {
+    readonly status = 101
+
+    constructor() {
+        super(null, {
+            status: 101,
+            statusText: "Switching Protocols",
+            headers: {
+                "Upgrade": "websocket",
+                "Connection": "Upgrade"
+            }
+        })
+    }
+}
+
+export async function writeResponseToSocket(socket: import("node:stream").Duplex, response: Response) {
+    let head = `HTTP/1.1 ${response.status}`
+    if (response.statusText) head += ` ${response.statusText}`
+    head += `\r\n`
+
+    for (const [name, value] of response.headers) {
+        head += `${name}: ${value}\r\n`
+    }
+
+    socket.write(head + "\r\n")
+
+    if (response.body) {
+        await pipeline(response.clone().body!, socket)
+    }
+}
\ No newline at end of file
diff --git a/packages/integrations/node/src/websocket/serve-websocket.ts b/packages/integrations/node/src/websocket/serve-websocket.ts
new file mode 100644
index 000000000..22712ea0e
--- /dev/null
+++ b/packages/integrations/node/src/websocket/serve-websocket.ts
@@ -0,0 +1,47 @@
+import * as ws from "ws"
+import { NodeApp } from "astro/app/node"
+import { WebSocket } from "./websocket.js"
+import { attach } from "./attach.js"
+import { UpgradeResponse, writeResponseToSocket } from "./response.js"
+
+export type UpgradeHandler =
+    import("node:http").Server["on"] extends
+        (event: "upgrade", callback: infer UpgradeHandler) => unknown
+            ? UpgradeHandler
+            : never
+
+export function createWebsocketHandler(app: NodeApp): UpgradeHandler {
+    /**
+     * The websocket instance is created as soon as
+     * `locals.upgradeWebSocket()` is called. It gets
+     * attached to an actual connection once the app
+     * code returns a response.
+     *
+     * This map is used to keep track of the
+     * responses' associated websocket instance.
+     */
+    const responseToSocketMap = new WeakMap<Response, WebSocket>
+    const server = new ws.WebSocketServer({ noServer: true })
+
+    return async (req, socket, head) => {
+        const response = await app.render(NodeApp.createRequest(req), {
+            addCookieHeader: true,
+            locals: {
+                isUpgradeRequest: true,
+                upgradeWebSocket() {
+                    const socket = new WebSocket
+                    const response = new UpgradeResponse
+                    responseToSocketMap.set(response, socket)
+                    return { socket, response }
+                }
+            }
+        })
+
+        if (response instanceof UpgradeResponse) {
+            const websocket = responseToSocketMap.get(response)!
+            server.handleUpgrade(req, socket, head, ws => attach(websocket, ws))
+        } else {
+            await writeResponseToSocket(socket, response)
+        }
+    }
+}
\ No newline at end of file
diff --git a/packages/integrations/node/src/websocket/websocket.ts b/packages/integrations/node/src/websocket/websocket.ts
new file mode 100644
index 000000000..00c8dd517
--- /dev/null
+++ b/packages/integrations/node/src/websocket/websocket.ts
@@ -0,0 +1,181 @@
+import type * as ws from "ws"
+
+type WebSocketInterface = globalThis.WebSocket
+
+// WeakMap to store private WebSocket instances
+const wsMap = new WeakMap<WebSocket, ws.WebSocket>()
+
+// To keep the internals hidden
+export const attacher: { attach: null | typeof attachImpl } = { attach: null }
+
+export class WebSocket extends EventTarget implements WebSocketInterface {
+
+    static readonly CONNECTING = 0 as const
+    static readonly OPEN       = 1 as const
+    static readonly CLOSING    = 2 as const
+    static readonly CLOSED     = 3 as const
+
+    get url() {
+        const ws = wsMap.get(this)
+        return ws?.url ?? ""
+    }
+
+    // ready state
+    declare readonly CONNECTING: 0
+    declare readonly OPEN      : 1
+    declare readonly CLOSING   : 2
+    declare readonly CLOSED    : 3
+
+    get readyState() {
+        const ws = wsMap.get(this)
+        return ws?.readyState ?? this.CONNECTING
+    }
+
+    get bufferedAmount() {
+        const ws = wsMap.get(this)
+        return ws?.bufferedAmount ?? 0
+    }
+
+    // networking
+    onopen : WebSocketInterface["onopen"]  = null
+    onerror: WebSocketInterface["onerror"] = null
+    onclose: WebSocketInterface["onclose"] = null
+
+    get extensions() {
+        const ws = wsMap.get(this)
+        return ws?.extensions ?? ""
+    }
+
+    get protocol() {
+        const ws = wsMap.get(this)
+        return ws?.protocol ?? ""
+    }
+
+    close() {
+        const ws = wsMap.get(this)
+        if (ws) ws.close()
+        else this.addEventListener("open", () => this.close(), { once: true })
+    }
+
+    // messaging
+    onmessage : WebSocketInterface["onmessage"] = null
+
+    get binaryType() {
+        const ws = wsMap.get(this)
+        return ws?.binaryType as "arraybuffer" | "blob" ?? "blob"
+    }
+
+    set binaryType(value: "arraybuffer" | "blob") {
+        const ws = wsMap.get(this)
+        if (ws) {
+            // @ts-expect-error `"blob"` is supported by `ws`
+            ws.binaryType = value
+        } else {
+            this.addEventListener("open", () => this.binaryType = value, { once: true })
+        }
+    }
+
+    send(data: string | ArrayBufferLike | Blob | ArrayBufferView) {
+        const ws = wsMap.get(this)
+        if (data instanceof Blob) data.arrayBuffer().then(buffer => ws!.send(buffer))
+        else ws!.send(data)
+    }
+
+    static {
+        Object.assign(this.prototype, {
+            CONNECTING: 0,
+            OPEN      : 1,
+            CLOSING   : 2,
+            CLOSED    : 3
+        })
+
+        // Freeze the prototype and class to align the object shape with the spec
+        Object.freeze(this.prototype)
+        Object.freeze(this)
+
+        attacher.attach = attachImpl
+    }
+}
+
+function attachImpl(standard: WebSocket, ws: ws.WebSocket): void {
+    // Use a WeakMap to store private WebSocket instances
+    if (wsMap.has(standard)) {
+        throw new Error("WebSocket already attached")
+    }
+    wsMap.set(standard, ws)
+    init(standard, ws)
+}
+
+function init(standard: WebSocket, ws: ws.WebSocket) {
+    // set the binary type to `"blob"` to align with the browser default
+    // @ts-expect-error `"blob"` is supported by `ws`
+    ws.binaryType = "blob"
+
+    if (ws.readyState === ws.OPEN) {
+        const event = new Event("open")
+        standard.onopen?.(event)
+        standard.dispatchEvent(event)
+    }
+
+    ws.on("open", function onOpen() {
+        const event = new Event("open")
+        standard.onopen?.(event)
+        standard.dispatchEvent(event)
+    })
+
+    ws.on("message", function onMessage(data, isBinary) {
+        const event = new MessageEvent("message", { data: isBinary ? data : data.toString(), })
+        standard.onmessage?.(event)
+        standard.dispatchEvent(event)
+    })
+
+    ws.on("error", function onError(error) {
+        const event = new ErrorEvent(error, error.message)
+        standard.onerror?.(event)
+        standard.dispatchEvent(event)
+    })
+
+    ws.addEventListener("close", function onClose(ev) {
+        const event = new (globalThis.CloseEvent ?? CloseEvent)("close", ev)
+        standard.onclose?.(event)
+        standard.dispatchEvent(event)
+    })
+}
+
+export class ErrorEvent extends Event {
+    constructor(readonly error: Error, readonly message: string) {
+        super("error")
+    }
+}
+
+export class CloseEvent extends Event implements globalThis.CloseEvent {
+    readonly code: number
+    readonly reason: string
+    readonly wasClean: boolean
+
+    constructor(type: string, eventInitDict: CloseEventInit) {
+        super(type, eventInitDict)
+        this.code = eventInitDict.code ?? 0
+        this.reason = eventInitDict.reason ?? ""
+        this.wasClean = eventInitDict.wasClean ?? false
+    }
+}
+
+export function attach(standard: WebSocket, ws: ws.WebSocket): void {
+    return attacher.attach?.(standard, ws)
+}
+
+interface CloseEventInit extends EventInit {
+    code?: number
+    reason?: string
+    wasClean?: boolean
+}
+
+declare global {
+    namespace App {
+        interface Locals {
+            isUpgradeRequest?: boolean
+            upgradeWebSocket?: () => { socket: WebSocket, response: import("./response.js").UpgradeResponse }
+        }
+    }
+}
+\ No newline at end of file
+diff --git a/packages/integrations/node/src/websocket/connection-manager.ts b/packages/integrations/node/src/websocket/connection-manager.ts
+new file mode 100644
+index 000000000..c4d4e9a12
+--- /dev/null
++++ b/packages/integrations/node/src/websocket/connection-manager.ts
+@@ -0,0 +1,873 @@
+/**
+ * Advanced WebSocket Connection Manager for zastro-websockets-node
+ * 
+ * This module provides comprehensive connection lifecycle management, background services,
+ * and advanced features beyond the basic WebSocketStats API. It includes connection pooling,
+ * rate limiting, health monitoring, and graceful shutdown coordination.
+ */
+
+import * as ws from "ws"
+import { EventEmitter } from "events"
+import type { WebSocket } from "./websocket.js"
+import { WebSocketStats, registerConnection, type ConnectionMetadata } from "./stats.js"
+
+/**
+ * Connection manager configuration options
+ */
+export interface ConnectionManagerConfig {
+  /** Maximum number of concurrent connections (default: 1000) */
+  maxConnections?: number
+  /** Maximum connections per IP address (default: 10) */
+  maxConnectionsPerIP?: number
+  /** Connection idle timeout in milliseconds (default: 300000 = 5 minutes) */
+  idleTimeout?: number
+  /** Rate limiting window in milliseconds (default: 60000 = 1 minute) */
+  rateLimitWindow?: number
+  /** Maximum connections per IP in rate limit window (default: 5) */
+  rateLimitMaxConnections?: number
+  /** Health check interval in milliseconds (default: 30000 = 30 seconds) */
+  healthCheckInterval?: number
+  /** Cleanup interval in milliseconds (default: 60000 = 1 minute) */
+  cleanupInterval?: number
+  /** Connection upgrade timeout in milliseconds (default: 5000) */
+  upgradeTimeout?: number
+  /** Enable connection pooling (default: true) */
+  enablePooling?: boolean
+  /** Enable rate limiting (default: true) */
+  enableRateLimit?: boolean
+  /** Enable health monitoring (default: true) */
+  enableHealthMonitoring?: boolean
+  /** Custom cleanup policy function */
+  customCleanupPolicy?: (connection: ManagedConnection) => boolean
+}
+
+/**
+ * Connection pool configuration
+ */
+export interface ConnectionPoolConfig {
+  /** Minimum pool size (default: 0) */
+  minSize?: number
+  /** Maximum pool size (default: 100) */
+  maxSize?: number
+  /** Connection reuse timeout in milliseconds (default: 180000 = 3 minutes) */
+  reuseTimeout?: number
+}
+
+/**
+ * Enhanced connection metadata with management features
+ */
+export interface ManagedConnection extends ConnectionMetadata {
+  /** Connection pool group */
+  poolGroup?: string
+  /** Rate limiting bucket */
+  rateLimitBucket: RateLimitBucket
+  /** Health status */
+  healthStatus: 'healthy' | 'unhealthy' | 'unknown'
+  /** Last health check timestamp */
+  lastHealthCheck: number
+  /** Connection tags for grouping and management */
+  tags: Set<string>
+  /** Custom metadata */
+  customData: Map<string, any>
+  /** Connection priority (1-10, 10 is highest) */
+  priority: number
+  /** Whether connection is eligible for cleanup */
+  eligibleForCleanup: boolean
+}
+
+/**
+ * Rate limiting bucket for per-IP tracking
+ */
+interface RateLimitBucket {
+  /** IP address */
+  ip: string
+  /** Connection count in current window */
+  connections: number
+  /** Window start timestamp */
+  windowStart: number
+  /** Last connection timestamp */
+  lastConnection: number
+}
+
+/**
+ * Connection health check result
+ */
+interface HealthCheckResult {
+  /** Whether connection is healthy */
+  healthy: boolean
+  /** Response time in milliseconds */
+  responseTime?: number
+  /** Error message if unhealthy */
+  error?: string
+}
+
+/**
+ * Connection manager events
+ */
+interface ConnectionManagerEvents {
+  'connection:added': [connection: ManagedConnection]
+  'connection:removed': [connectionId: string, reason: string]
+  'connection:health': [connectionId: string, result: HealthCheckResult]
+  'connection:idle': [connectionId: string, idleTime: number]
+  'pool:full': [rejectedConnection: { ip: string, userAgent?: string }]
+  'ratelimit:exceeded': [ip: string, attempt: number]
+  'cleanup:started': []
+  'cleanup:completed': [removedCount: number]
+  'shutdown:started': []
+  'shutdown:completed': []
+  'error': [error: Error, context?: string]
+}
+
+/**
+ * Advanced WebSocket Connection Manager
+ * 
+ * Provides comprehensive connection lifecycle management with features like:
+ * - Connection pooling and limits
+ * - Rate limiting per IP
+ * - Health monitoring and checks
+ * - Background cleanup services
+ * - Graceful shutdown coordination
+ * - Event-driven architecture
+ */
+export class ConnectionManager extends EventEmitter<ConnectionManagerEvents> {
+  private connections = new Map<string, ManagedConnection>()
+  private connectionsByIP = new Map<string, Set<string>>()
+  private rateLimitBuckets = new Map<string, RateLimitBucket>()
+  private cleanupInterval?: NodeJS.Timeout
+  private healthCheckInterval?: NodeJS.Timeout
+  private isShutdown = false
+  private config: Required<ConnectionManagerConfig>
+
+  constructor(config: ConnectionManagerConfig = {}) {
+    super()
+    
+    // Set default configuration
+    this.config = {
+      maxConnections: config.maxConnections ?? 1000,
+      maxConnectionsPerIP: config.maxConnectionsPerIP ?? 10,
+      idleTimeout: config.idleTimeout ?? 300000, // 5 minutes
+      rateLimitWindow: config.rateLimitWindow ?? 60000, // 1 minute
+      rateLimitMaxConnections: config.rateLimitMaxConnections ?? 5,
+      healthCheckInterval: config.healthCheckInterval ?? 30000, // 30 seconds
+      cleanupInterval: config.cleanupInterval ?? 60000, // 1 minute
+      upgradeTimeout: config.upgradeTimeout ?? 5000,
+      enablePooling: config.enablePooling ?? true,
+      enableRateLimit: config.enableRateLimit ?? true,
+      enableHealthMonitoring: config.enableHealthMonitoring ?? true,
+      customCleanupPolicy: config.customCleanupPolicy ?? (() => false)
+    }
+
+    this.startBackgroundServices()
+  }
+
+  /**
+   * Check if a new connection can be accepted
+   */
+  canAcceptConnection(remoteAddress?: string): {
+    allowed: boolean
+    reason?: string
+  } {
+    if (this.isShutdown) {
+      return { allowed: false, reason: 'Server is shutting down' }
+    }
+
+    // Check global connection limit
+    if (this.config.enablePooling && this.connections.size >= this.config.maxConnections) {
+      this.emit('pool:full', { ip: remoteAddress || 'unknown' })
+      return { allowed: false, reason: 'Maximum connections reached' }
+    }
+
+    // Check per-IP connection limit
+    if (remoteAddress && this.config.enablePooling) {
+      const ipConnections = this.connectionsByIP.get(remoteAddress)
+      if (ipConnections && ipConnections.size >= this.config.maxConnectionsPerIP) {
+        return { allowed: false, reason: 'Maximum connections per IP reached' }
+      }
+    }
+
+    // Check rate limiting
+    if (remoteAddress && this.config.enableRateLimit) {
+      const rateLimitResult = this.checkRateLimit(remoteAddress)
+      if (!rateLimitResult.allowed) {
+        this.emit('ratelimit:exceeded', remoteAddress, rateLimitResult.currentConnections || 0)
+        return { allowed: false, reason: 'Rate limit exceeded' }
+      }
+    }
+
+    return { allowed: true }
+  }
+
+  /**
+   * Register a new managed connection
+   */
+  registerManagedConnection(
+    socket: WebSocket,
+    wsSocket: ws.WebSocket,
+    req?: import('node:http').IncomingMessage,
+    options: {
+      poolGroup?: string
+      tags?: string[]
+      priority?: number
+      customData?: Record<string, any>
+    } = {}
+  ): string {
+    const remoteAddress = req?.socket.remoteAddress || req?.headers['x-forwarded-for'] as string
+    const userAgent = req?.headers['user-agent']
+
+    // Check if connection can be accepted
+    const canAccept = this.canAcceptConnection(remoteAddress)
+    if (!canAccept.allowed) {
+      throw new Error(`Connection rejected: ${canAccept.reason}`)
+    }
+
+    // Register with base stats system
+    const connectionId = registerConnection(socket, wsSocket, req)
+
+    // Create rate limit bucket
+    const rateLimitBucket = this.getOrCreateRateLimitBucket(remoteAddress)
+    rateLimitBucket.connections++
+    rateLimitBucket.lastConnection = Date.now()
+
+    // Create managed connection
+    const baseConnection = WebSocketStats.getConnection(connectionId)
+    if (!baseConnection) {
+      throw new Error('Failed to register connection with stats system')
+    }
+
+    const managedConnection: ManagedConnection = {
+      ...baseConnection,
+      poolGroup: options.poolGroup,
+      rateLimitBucket,
+      healthStatus: 'unknown',
+      lastHealthCheck: 0,
+      tags: new Set(options.tags || []),
+      customData: new Map(Object.entries(options.customData || {})),
+      priority: options.priority ?? 5,
+      eligibleForCleanup: false
+    }
+
+    // Store connection
+    this.connections.set(connectionId, managedConnection)
+
+    // Track by IP
+    if (remoteAddress) {
+      if (!this.connectionsByIP.has(remoteAddress)) {
+        this.connectionsByIP.set(remoteAddress, new Set())
+      }
+      this.connectionsByIP.get(remoteAddress)!.add(connectionId)
+    }
+
+    // Set up enhanced event listeners
+    this.setupManagedConnectionEventListeners(managedConnection)
+
+    this.emit('connection:added', managedConnection)
+
+    return connectionId
+  }
+
+  /**
+   * Remove a managed connection
+   */
+  removeManagedConnection(connectionId: string, reason: string = 'Unknown'): void {
+    const connection = this.connections.get(connectionId)
+    if (!connection) return
+
+    // Remove from IP tracking
+    if (connection.remoteAddress) {
+      const ipConnections = this.connectionsByIP.get(connection.remoteAddress)
+      if (ipConnections) {
+        ipConnections.delete(connectionId)
+        if (ipConnections.size === 0) {
+          this.connectionsByIP.delete(connection.remoteAddress)
+        }
+      }
+    }
+
+    // Update rate limit bucket
+    if (connection.rateLimitBucket) {
+      connection.rateLimitBucket.connections = Math.max(0, connection.rateLimitBucket.connections - 1)
+    }
+
+    // Remove from managed connections
+    this.connections.delete(connectionId)
+
+    this.emit('connection:removed', connectionId, reason)
+  }
+
+  /**
+   * Get managed connection by ID
+   */
+  getManagedConnection(connectionId: string): ManagedConnection | undefined {
+    return this.connections.get(connectionId)
+  }
+
+  /**
+   * Get all managed connections
+   */
+  getAllManagedConnections(): ManagedConnection[] {
+    return Array.from(this.connections.values())
+  }
+
+  /**
+   * Get connections by tag
+   */
+  getConnectionsByTag(tag: string): ManagedConnection[] {
+    return Array.from(this.connections.values()).filter(conn => conn.tags.has(tag))
+  }
+
+  /**
+   * Get connections by pool group
+   */
+  getConnectionsByPoolGroup(poolGroup: string): ManagedConnection[] {
+    return Array.from(this.connections.values()).filter(conn => conn.poolGroup === poolGroup)
+  }
+
+  /**
+   * Get connections by IP address
+   */
+  getConnectionsByIP(ip: string): ManagedConnection[] {
+    const connectionIds = this.connectionsByIP.get(ip)
+    if (!connectionIds) return []
+    
+    return Array.from(connectionIds)
+      .map(id => this.connections.get(id))
+      .filter((conn): conn is ManagedConnection => conn !== undefined)
+  }
+
+  /**
+   * Add tag to connection
+   */
+  addConnectionTag(connectionId: string, tag: string): boolean {
+    const connection = this.connections.get(connectionId)
+    if (!connection) return false
+    
+    connection.tags.add(tag)
+    return true
+  }
+
+  /**
+   * Remove tag from connection
+   */
+  removeConnectionTag(connectionId: string, tag: string): boolean {
+    const connection = this.connections.get(connectionId)
+    if (!connection) return false
+    
+    return connection.tags.delete(tag)
+  }
+
+  /**
+   * Set custom data for connection
+   */
+  setConnectionData(connectionId: string, key: string, value: any): boolean {
+    const connection = this.connections.get(connectionId)
+    if (!connection) return false
+    
+    connection.customData.set(key, value)
+    return true
+  }
+
+  /**
+   * Get custom data for connection
+   */
+  getConnectionData(connectionId: string, key: string): any {
+    const connection = this.connections.get(connectionId)
+    return connection?.customData.get(key)
+  }
+
+  /**
+   * Perform health check on a connection
+   */
+  async performHealthCheck(connectionId: string): Promise<HealthCheckResult> {
+    const connection = this.connections.get(connectionId)
+    if (!connection) {
+      return { healthy: false, error: 'Connection not found' }
+    }
+
+    const startTime = Date.now()
+
+    try {
+      // Check if socket is still open
+      if (connection.state !== 'OPEN') {
+        return { healthy: false, error: `Connection state is ${connection.state}` }
+      }
+
+      // Send ping and wait for pong (if WebSocket supports it)
+      const wsSocket = connection.wsSocket
+      if (wsSocket && typeof wsSocket.ping === 'function') {
+        return new Promise<HealthCheckResult>((resolve) => {
+          const timeout = setTimeout(() => {
+            resolve({ 
+              healthy: false, 
+              error: 'Health check timeout',
+              responseTime: Date.now() - startTime
+            })
+          }, 5000)
+
+          wsSocket.ping()
+          wsSocket.once('pong', () => {
+            clearTimeout(timeout)
+            resolve({
+              healthy: true,
+              responseTime: Date.now() - startTime
+            })
+          })
+        })
+      }
+
+      // Fallback: just check if connection is open
+      return {
+        healthy: connection.state === 'OPEN',
+        responseTime: Date.now() - startTime
+      }
+    } catch (error) {
+      return {
+        healthy: false,
+        error: error instanceof Error ? error.message : 'Unknown error',
+        responseTime: Date.now() - startTime
+      }
+    }
+  }
+
+  /**
+   * Close connections by criteria
+   */
+  closeConnections(criteria: {
+    tags?: string[]
+    poolGroup?: string
+    ip?: string
+    olderThan?: number
+    idleMoreThan?: number
+    priority?: number
+    unhealthy?: boolean
+  }, code?: number, reason?: string): number {
+    let closedCount = 0
+    const connections = Array.from(this.connections.values())
+
+    for (const connection of connections) {
+      let shouldClose = true
+
+      // Check criteria
+      if (criteria.tags && !criteria.tags.some(tag => connection.tags.has(tag))) {
+        shouldClose = false
+      }
+      if (criteria.poolGroup && connection.poolGroup !== criteria.poolGroup) {
+        shouldClose = false
+      }
+      if (criteria.ip && connection.remoteAddress !== criteria.ip) {
+        shouldClose = false
+      }
+      if (criteria.olderThan && connection.age < criteria.olderThan) {
+        shouldClose = false
+      }
+      if (criteria.idleMoreThan && connection.idleTime < criteria.idleMoreThan) {
+        shouldClose = false
+      }
+      if (criteria.priority !== undefined && connection.priority !== criteria.priority) {
+        shouldClose = false
+      }
+      if (criteria.unhealthy && connection.healthStatus === 'healthy') {
+        shouldClose = false
+      }
+
+      if (shouldClose) {
+        try {
+          if (code !== undefined || reason !== undefined) {
+            connection.wsSocket.close(code, reason)
+          } else {
+            connection.socket.close()
+          }
+          closedCount++
+        } catch (error) {
+          console.warn(`Failed to close connection ${connection.id}:`, error)
+        }
+      }
+    }
+
+    return closedCount
+  }
+
+  /**
+   * Get connection manager statistics
+   */
+  getManagerStats() {
+    const connections = Array.from(this.connections.values())
+    const now = Date.now()
+
+    // Group by health status
+    const healthStats = connections.reduce((acc, conn) => {
+      acc[conn.healthStatus] = (acc[conn.healthStatus] || 0) + 1
+      return acc
+    }, {} as Record<string, number>)
+
+    // Group by pool group
+    const poolStats = connections.reduce((acc, conn) => {
+      const group = conn.poolGroup || 'default'
+      acc[group] = (acc[group] || 0) + 1
+      return acc
+    }, {} as Record<string, number>)
+
+    // Calculate idle connections
+    const idleConnections = connections.filter(conn => 
+      conn.idleTime > this.config.idleTimeout
+    ).length
+
+    return {
+      totalManagedConnections: this.connections.size,
+      connectionsByIP: this.connectionsByIP.size,
+      rateLimitBuckets: this.rateLimitBuckets.size,
+      healthStats,
+      poolStats,
+      idleConnections,
+      config: this.config,
+      isShutdown: this.isShutdown
+    }
+  }
+
+  /**
+   * Start background services
+   */
+  private startBackgroundServices(): void {
+    // Start cleanup service
+    this.cleanupInterval = setInterval(() => {
+      this.performCleanup()
+    }, this.config.cleanupInterval)
+
+    // Start health monitoring
+    if (this.config.enableHealthMonitoring) {
+      this.healthCheckInterval = setInterval(() => {
+        this.performHealthChecks()
+      }, this.config.healthCheckInterval)
+    }
+  }
+
+  /**
+   * Stop background services
+   */
+  private stopBackgroundServices(): void {
+    if (this.cleanupInterval) {
+      clearInterval(this.cleanupInterval)
+      this.cleanupInterval = undefined
+    }
+
+    if (this.healthCheckInterval) {
+      clearInterval(this.healthCheckInterval)
+      this.healthCheckInterval = undefined
+    }
+  }
+
+  /**
+   * Perform periodic cleanup
+   */
+  private async performCleanup(): Promise<void> {
+    if (this.isShutdown) return
+
+    this.emit('cleanup:started')
+    let removedCount = 0
+
+    const connections = Array.from(this.connections.values())
+    const now = Date.now()
+
+    for (const connection of connections) {
+      let shouldRemove = false
+      let reason = ''
+
+      // Check if connection is closed but not cleaned up
+      if (connection.state === 'CLOSED') {
+        shouldRemove = true
+        reason = 'Connection already closed'
+      }
+      // Check idle timeout
+      else if (connection.idleTime > this.config.idleTimeout) {
+        shouldRemove = true
+        reason = 'Idle timeout exceeded'
+        try {
+          connection.wsSocket.close(1001, 'Idle timeout')
+        } catch (error) {
+          console.warn(`Failed to close idle connection ${connection.id}:`, error)
+        }
+      }
+      // Check custom cleanup policy
+      else if (this.config.customCleanupPolicy(connection)) {
+        shouldRemove = true
+        reason = 'Custom cleanup policy'
+        try {
+          connection.wsSocket.close(1000, 'Custom cleanup')
+        } catch (error) {
+          console.warn(`Failed to close connection ${connection.id} via custom policy:`, error)
+        }
+      }
+
+      if (shouldRemove) {
+        this.removeManagedConnection(connection.id, reason)
+        removedCount++
+      }
+    }
+
+    // Clean up old rate limit buckets
+    for (const [ip, bucket] of this.rateLimitBuckets.entries()) {
+      if (now - bucket.windowStart > this.config.rateLimitWindow && bucket.connections === 0) {
+        this.rateLimitBuckets.delete(ip)
+      }
+    }
+
+    this.emit('cleanup:completed', removedCount)
+  }
+
+  /**
+   * Perform health checks on all connections
+   */
+  private async performHealthChecks(): Promise<void> {
+    if (this.isShutdown) return
+
+    const connections = Array.from(this.connections.values())
+    
+    // Perform health checks in batches to avoid overwhelming
+    const batchSize = 10
+    for (let i = 0; i < connections.length; i += batchSize) {
+      const batch = connections.slice(i, i + batchSize)
+      
+      await Promise.all(batch.map(async (connection) => {
+        try {
+          const result = await this.performHealthCheck(connection.id)
+          connection.healthStatus = result.healthy ? 'healthy' : 'unhealthy'
+          connection.lastHealthCheck = Date.now()
+          
+          this.emit('connection:health', connection.id, result)
+        } catch (error) {
+          connection.healthStatus = 'unhealthy'
+          connection.lastHealthCheck = Date.now()
+          
+          this.emit('connection:health', connection.id, {
+            healthy: false,
+            error: error instanceof Error ? error.message : 'Unknown error'
+          })
+        }
+      }))
+    }
+  }
+
+  /**
+   * Check rate limiting for IP address
+   */
+  private checkRateLimit(ip: string): { allowed: boolean; currentConnections?: number } {
+    const bucket = this.getOrCreateRateLimitBucket(ip)
+    const now = Date.now()
+
+    // Reset window if expired
+    if (now - bucket.windowStart > this.config.rateLimitWindow) {
+      bucket.connections = 0
+      bucket.windowStart = now
+    }
+
+    return {
+      allowed: bucket.connections < this.config.rateLimitMaxConnections,
+      currentConnections: bucket.connections
+    }
+  }
+
+  /**
+   * Get or create rate limit bucket for IP
+   */
+  private getOrCreateRateLimitBucket(ip?: string): RateLimitBucket {
+    const address = ip || 'unknown'
+    
+    if (!this.rateLimitBuckets.has(address)) {
+      this.rateLimitBuckets.set(address, {
+        ip: address,
+        connections: 0,
+        windowStart: Date.now(),
+        lastConnection: Date.now()
+      })
+    }
+
+    return this.rateLimitBuckets.get(address)!
+  }
+
+  /**
+   * Set up enhanced event listeners for managed connection
+   */
+  private setupManagedConnectionEventListeners(connection: ManagedConnection): void {
+    const { socket, id } = connection
+
+    // Track activity
+    const trackActivity = () => {
+      connection.lastActivity = Date.now()
+    }
+
+    socket.addEventListener('message', trackActivity)
+    socket.addEventListener('error', trackActivity)
+
+    // Handle close event
+    socket.addEventListener('close', () => {
+      this.removeManagedConnection(id, 'Connection closed')
+    })
+
+    // Monitor for idle connections
+    const idleCheckInterval = setInterval(() => {
+      if (connection.idleTime > this.config.idleTimeout / 2) {
+        this.emit('connection:idle', id, connection.idleTime)
+      }
+    }, 60000) // Check every minute
+
+    // Clean up interval when connection closes
+    socket.addEventListener('close', () => {
+      clearInterval(idleCheckInterval)
+    })
+  }
+
+  /**
+   * Graceful shutdown of connection manager
+   */
+  async shutdown(options: {
+    timeout?: number
+    closeCode?: number
+    closeReason?: string
+  } = {}): Promise<void> {
+    if (this.isShutdown) return
+
+    this.isShutdown = true
+    this.emit('shutdown:started')
+
+    const { timeout = 5000, closeCode = 1001, closeReason = 'Server shutting down' } = options
+
+    try {
+      // Stop background services
+      this.stopBackgroundServices()
+
+      // Close all connections
+      const connections = Array.from(this.connections.values())
+      const closePromises = connections.map(connection => {
+        return new Promise<void>((resolve) => {
+          const cleanup = () => {
+            resolve()
+          }
+
+          connection.socket.addEventListener('close', cleanup)
+          
+          // Set timeout for forced close
+          setTimeout(cleanup, 1000)
+
+          try {
+            connection.wsSocket.close(closeCode, closeReason)
+          } catch (error) {
+            console.warn(`Failed to close connection ${connection.id}:`, error)
+            cleanup()
+          }
+        })
+      })
+
+      // Wait for all connections to close or timeout
+      await Promise.race([
+        Promise.all(closePromises),
+        new Promise(resolve => setTimeout(resolve, timeout))
+      ])
+
+      // Clear all data structures
+      this.connections.clear()
+      this.connectionsByIP.clear()
+      this.rateLimitBuckets.clear()
+
+      this.emit('shutdown:completed')
+    } catch (error) {
+      this.emit('error', error instanceof Error ? error : new Error(String(error)), 'shutdown')
+      throw error
+    }
+  }
+
+  /**
+   * Get configuration
+   */
+  getConfig(): Required<ConnectionManagerConfig> {
+    return { ...this.config }
+  }
+
+  /**
+   * Update configuration (only some settings can be changed at runtime)
+   */
+  updateConfig(updates: Partial<Pick<ConnectionManagerConfig, 
+    'maxConnections' | 'maxConnectionsPerIP' | 'idleTimeout' | 
+    'rateLimitMaxConnections' | 'customCleanupPolicy'
+  >>): void {
+    Object.assign(this.config, updates)
+  }
+}
+
+// Global singleton instance
+let globalConnectionManager: ConnectionManager | undefined
+
+/**
+ * Get or create the global connection manager instance
+ */
+export function getConnectionManager(config?: ConnectionManagerConfig): ConnectionManager {
+  if (!globalConnectionManager) {
+    globalConnectionManager = new ConnectionManager(config)
+  }
+  return globalConnectionManager
+}
+
+/**
+ * Reset the global connection manager (useful for testing)
+ */
+export function resetConnectionManager(): void {
+  if (globalConnectionManager) {
+    globalConnectionManager.shutdown()
+    globalConnectionManager = undefined
+  }
+}
+
+/**
+ * Connection Manager API for easy access to common operations
+ */
+export const ConnectionManagerAPI = {
+  /**
+   * Get the global connection manager
+   */
+  getInstance: (config?: ConnectionManagerConfig) => getConnectionManager(config),
+
+  /**
+   * Register a new managed connection
+   */
+  register: (
+    socket: WebSocket,
+    wsSocket: ws.WebSocket,
+    req?: import('node:http').IncomingMessage,
+    options?: Parameters<ConnectionManager['registerManagedConnection']>[3]
+  ) => getConnectionManager().registerManagedConnection(socket, wsSocket, req, options),
+
+  /**
+   * Get connection manager statistics
+   */
+  getStats: () => getConnectionManager().getManagerStats(),
+
+  /**
+   * Perform health check on all connections
+   */
+  healthCheck: async () => {
+    const manager = getConnectionManager()
+    const connections = manager.getAllManagedConnections()
+    const results = await Promise.all(
+      connections.map(async (conn) => ({
+        id: conn.id,
+        result: await manager.performHealthCheck(conn.id)
+      }))
+    )
+    return results
+  },
+
+  /**
+   * Close connections by criteria
+   */
+  closeConnections: (
+    criteria: Parameters<ConnectionManager['closeConnections']>[0],
+    code?: number,
+    reason?: string
+  ) => getConnectionManager().closeConnections(criteria, code, reason),
+
+  /**
+   * Graceful shutdown
+   */
+  shutdown: (options?: Parameters<ConnectionManager['shutdown']>[0]) => 
+    getConnectionManager().shutdown(options)
+} as const
+
+export default ConnectionManagerAPI
+\ No newline at end of file
+diff --git a/packages/integrations/node/src/websocket/stats.ts b/packages/integrations/node/src/websocket/stats.ts
+new file mode 100644
+index 000000000..b4f2e1a42
+--- /dev/null
++++ b/packages/integrations/node/src/websocket/stats.ts
+@@ -0,0 +1,476 @@
+/**
+ * WebSocket connection statistics and management for zastro-websockets-node
+ * 
+ * This module provides comprehensive connection tracking, statistics, and administrative
+ * functions for managing WebSocket connections in production environments.
+ */
+
+import * as ws from "ws"
+import type { WebSocket } from "./websocket.js"
+
+/**
+ * Metadata about a WebSocket connection
+ */
+export interface ConnectionMetadata {
+  /** Unique connection identifier */
+  id: string
+  /** WebSocket instance */
+  socket: WebSocket
+  /** Underlying ws.WebSocket instance */
+  wsSocket: ws.WebSocket
+  /** Connection establishment timestamp */
+  connectedAt: number
+  /** Last activity timestamp */
+  lastActivity: number
+  /** Remote IP address */
+  remoteAddress?: string
+  /** User agent string */
+  userAgent?: string
+  /** Connection age in milliseconds */
+  get age(): number
+  /** Idle time in milliseconds since last activity */
+  get idleTime(): number
+  /** Current connection state */
+  get state(): 'CONNECTING' | 'OPEN' | 'CLOSING' | 'CLOSED'
+}
+
+/**
+ * Connection statistics summary
+ */
+export interface ConnectionStats {
+  /** Total number of active connections */
+  totalConnections: number
+  /** Total connections established since startup */
+  totalConnectionsEver: number
+  /** Total connections closed since startup */
+  totalConnectionsClosed: number
+  /** Average connection age in milliseconds */
+  averageAge: number
+  /** Average idle time in milliseconds */
+  averageIdleTime: number
+  /** Connections by state */
+  connectionsByState: {
+    CONNECTING: number
+    OPEN: number
+    CLOSING: number
+    CLOSED: number
+  }
+  /** Detailed connection information */
+  connections: Array<{
+    id: string
+    age: number
+    idleTime: number
+    state: string
+    remoteAddress?: string
+    userAgent?: string
+  }>
+}
+
+/**
+ * WebSocket statistics and connection management
+ */
+class WebSocketStatsManager {
+  private connections = new Map<string, ConnectionMetadata>()
+  private connectionCounter = 0
+  private totalConnectionsEver = 0
+  private totalConnectionsClosed = 0
+  private cleanupInterval?: NodeJS.Timeout
+  private isShutdown = false
+
+  constructor() {
+    // Start periodic cleanup of stale connections
+    this.startCleanupInterval()
+  }
+
+  /**
+   * Register a new WebSocket connection for tracking
+   */
+  registerConnection(
+    socket: WebSocket, 
+    wsSocket: ws.WebSocket, 
+    remoteAddress?: string, 
+    userAgent?: string
+  ): string {
+    if (this.isShutdown) {
+      throw new Error("WebSocketStats has been shutdown")
+    }
+
+    const id = `ws_${++this.connectionCounter}_${Date.now()}`
+    this.totalConnectionsEver++
+
+    const metadata: ConnectionMetadata = {
+      id,
+      socket,
+      wsSocket,
+      connectedAt: Date.now(),
+      lastActivity: Date.now(),
+      remoteAddress,
+      userAgent,
+      get age() {
+        return Date.now() - this.connectedAt
+      },
+      get idleTime() {
+        return Date.now() - this.lastActivity
+      },
+      get state() {
+        const readyState = wsSocket.readyState
+        switch (readyState) {
+          case ws.WebSocket.CONNECTING: return 'CONNECTING'
+          case ws.WebSocket.OPEN: return 'OPEN'
+          case ws.WebSocket.CLOSING: return 'CLOSING'
+          case ws.WebSocket.CLOSED: return 'CLOSED'
+          default: return 'CLOSED'
+        }
+      }
+    }
+
+    this.connections.set(id, metadata)
+
+    // Set up event listeners to track activity and cleanup
+    this.setupConnectionEventListeners(metadata)
+
+    return id
+  }
+
+  /**
+   * Set up event listeners for connection lifecycle tracking
+   */
+  private setupConnectionEventListeners(metadata: ConnectionMetadata): void {
+    const { socket, wsSocket, id } = metadata
+
+    // Track message activity
+    const onMessage = () => {
+      metadata.lastActivity = Date.now()
+    }
+
+    // Clean up on close
+    const onClose = () => {
+      this.unregisterConnection(id)
+    }
+
+    // Track error events
+    const onError = () => {
+      metadata.lastActivity = Date.now()
+    }
+
+    // Add listeners
+    socket.addEventListener('message', onMessage)
+    socket.addEventListener('close', onClose)
+    socket.addEventListener('error', onError)
+
+    // Also track on the underlying ws socket for completeness
+    wsSocket.on('message', onMessage)
+    wsSocket.on('close', onClose)
+    wsSocket.on('error', onError)
+  }
+
+  /**
+   * Unregister a connection (called automatically on close)
+   */
+  private unregisterConnection(id: string): void {
+    if (this.connections.delete(id)) {
+      this.totalConnectionsClosed++
+    }
+  }
+
+  /**
+   * Get the total number of active connections
+   */
+  getConnectionCount(): number {
+    return this.connections.size
+  }
+
+  /**
+   * Get detailed connection statistics
+   */
+  getConnectionStats(): ConnectionStats {
+    const connections = Array.from(this.connections.values())
+    const now = Date.now()
+
+    // Calculate averages
+    const totalAge = connections.reduce((sum, conn) => sum + conn.age, 0)
+    const totalIdleTime = connections.reduce((sum, conn) => sum + conn.idleTime, 0)
+    const averageAge = connections.length > 0 ? totalAge / connections.length : 0
+    const averageIdleTime = connections.length > 0 ? totalIdleTime / connections.length : 0
+
+    // Count by state
+    const connectionsByState = {
+      CONNECTING: 0,
+      OPEN: 0,
+      CLOSING: 0,
+      CLOSED: 0
+    }
+
+    connections.forEach(conn => {
+      connectionsByState[conn.state]++
+    })
+
+    return {
+      totalConnections: this.connections.size,
+      totalConnectionsEver: this.totalConnectionsEver,
+      totalConnectionsClosed: this.totalConnectionsClosed,
+      averageAge,
+      averageIdleTime,
+      connectionsByState,
+      connections: connections.map(conn => ({
+        id: conn.id,
+        age: conn.age,
+        idleTime: conn.idleTime,
+        state: conn.state,
+        remoteAddress: conn.remoteAddress,
+        userAgent: conn.userAgent
+      }))
+    }
+  }
+
+  /**
+   * Get set of active WebSocket instances
+   */
+  getActiveConnections(): Set<WebSocket> {
+    const activeConnections = new Set<WebSocket>()
+    const connections = Array.from(this.connections.values())
+    for (const metadata of connections) {
+      if (metadata.state === 'OPEN') {
+        activeConnections.add(metadata.socket)
+      }
+    }
+    return activeConnections
+  }
+
+  /**
+   * Close all active connections
+   */
+  closeAllConnections(code?: number, reason?: string): void {
+    const connections = Array.from(this.connections.values())
+    connections.forEach(metadata => {
+      try {
+        if (metadata.state === 'OPEN' || metadata.state === 'CONNECTING') {
+          // Use the underlying ws socket for close with code/reason
+          if (code !== undefined || reason !== undefined) {
+            metadata.wsSocket.close(code, reason)
+          } else {
+            metadata.socket.close()
+          }
+        }
+      } catch (error) {
+        console.warn(`Failed to close WebSocket connection ${metadata.id}:`, error)
+      }
+    })
+  }
+
+  /**
+   * Clean up stale connections (already closed but not cleaned up)
+   */
+  cleanupStaleConnections(): number {
+    let cleaned = 0
+    const staleIds: string[] = []
+    const entries = Array.from(this.connections.entries())
+
+    for (const [id, metadata] of entries) {
+      if (metadata.state === 'CLOSED') {
+        staleIds.push(id)
+      }
+    }
+
+    staleIds.forEach(id => {
+      this.connections.delete(id)
+      cleaned++
+    })
+
+    return cleaned
+  }
+
+  /**
+   * Start periodic cleanup interval
+   */
+  private startCleanupInterval(): void {
+    // Clean up stale connections every 30 seconds
+    this.cleanupInterval = setInterval(() => {
+      this.cleanupStaleConnections()
+    }, 30000)
+  }
+
+  /**
+   * Graceful shutdown - close all connections and cleanup
+   */
+  shutdown(): void {
+    if (this.isShutdown) return
+
+    this.isShutdown = true
+
+    // Clear cleanup interval
+    if (this.cleanupInterval) {
+      clearInterval(this.cleanupInterval)
+      this.cleanupInterval = undefined
+    }
+
+    // Close all connections gracefully
+    this.closeAllConnections(1001, 'Server shutting down')
+
+    // Wait a moment for graceful closes, then force cleanup
+    setTimeout(() => {
+      this.connections.clear()
+    }, 1000)
+  }
+
+  /**
+   * Update activity timestamp for a connection
+   */
+  updateActivity(connectionId: string): void {
+    const metadata = this.connections.get(connectionId)
+    if (metadata) {
+      metadata.lastActivity = Date.now()
+    }
+  }
+
+  /**
+   * Get connection metadata by ID
+   */
+  getConnection(connectionId: string): ConnectionMetadata | undefined {
+    return this.connections.get(connectionId)
+  }
+
+  /**
+   * Get all connection IDs
+   */
+  getConnectionIds(): string[] {
+    return Array.from(this.connections.keys())
+  }
+
+  /**
+   * Check if stats manager is shutdown
+   */
+  get isShutDown(): boolean {
+    return this.isShutdown
+  }
+}
+
+// Global singleton instance
+const statsManager = new WebSocketStatsManager()
+
+/**
+ * WebSocket Statistics API
+ * 
+ * Provides connection tracking, statistics, and administrative functions
+ * for WebSocket connections in Node.js environments.
+ */
+export const WebSocketStats = {
+  /**
+   * Get total number of active connections
+   */
+  getConnectionCount: () => statsManager.getConnectionCount(),
+
+  /**
+   * Get detailed connection statistics
+   */
+  getConnectionStats: () => statsManager.getConnectionStats(),
+
+  /**
+   * Get set of active WebSocket instances
+   */
+  getActiveConnections: () => statsManager.getActiveConnections(),
+
+  /**
+   * Close all active connections
+   */
+  closeAllConnections: (code?: number, reason?: string) => 
+    statsManager.closeAllConnections(code, reason),
+
+  /**
+   * Graceful shutdown of connection manager
+   */
+  shutdown: () => statsManager.shutdown(),
+
+  /**
+   * Clean up stale connections
+   */
+  cleanupStaleConnections: () => statsManager.cleanupStaleConnections(),
+
+  /**
+   * Get connection metadata by ID
+   */
+  getConnection: (id: string) => statsManager.getConnection(id),
+
+  /**
+   * Get all connection IDs
+   */
+  getConnectionIds: () => statsManager.getConnectionIds(),
+
+  /**
+   * Check if stats manager is shutdown
+   */
+  get isShutDown() { return statsManager.isShutDown }
+} as const
+
+/**
+ * Register a new WebSocket connection for tracking
+ * This function should be called by the WebSocket attachment code
+ */
+export function registerConnection(
+  socket: WebSocket, 
+  wsSocket: ws.WebSocket,
+  req?: import('node:http').IncomingMessage
+): string {
+  const remoteAddress = req?.socket.remoteAddress || req?.headers['x-forwarded-for'] as string
+  const userAgent = req?.headers['user-agent']
+  
+  return statsManager.registerConnection(socket, wsSocket, remoteAddress, userAgent)
+}
+
+/**
+ * Update activity for a connection
+ */
+export function updateConnectionActivity(connectionId: string): void {
+  statsManager.updateActivity(connectionId)
+}
+
+/**
+ * Utility function to log connection statistics
+ */
+export function logConnectionStats(): void {
+  const stats = WebSocketStats.getConnectionStats()
+  console.log(`[WebSocket Stats] Active: ${stats.totalConnections}, Total: ${stats.totalConnectionsEver}, Closed: ${stats.totalConnectionsClosed}`)
+  
+  if (stats.totalConnections > 0) {
+    console.log(`[WebSocket Stats] Avg Age: ${Math.round(stats.averageAge / 1000)}s, Avg Idle: ${Math.round(stats.averageIdleTime / 1000)}s`)
+    console.log(`[WebSocket Stats] By State - Open: ${stats.connectionsByState.OPEN}, Connecting: ${stats.connectionsByState.CONNECTING}, Closing: ${stats.connectionsByState.CLOSING}`)
+  }
+}
+
+/**
+ * Create middleware function for stats tracking
+ */
+export function createStatsMiddleware() {
+  return {
+    name: 'websocket-stats',
+    hooks: {
+      'astro:server:setup': ({ server }: { server: any }) => {
+        // Log stats periodically
+        const interval = setInterval(() => {
+          logConnectionStats()
+        }, 30000)
+
+        // Clean up on server close
+        if (server?.httpServer) {
+          server.httpServer.on('close', () => {
+            clearInterval(interval)
+            statsManager.shutdown()
+          })
+        }
+      }
+    }
+  }
+}
+
+// Handle process shutdown gracefully
+process.on('SIGINT', () => {
+  console.log('\n[WebSocket Stats] Received SIGINT, shutting down gracefully...')
+  statsManager.shutdown()
+})
+
+process.on('SIGTERM', () => {
+  console.log('\n[WebSocket Stats] Received SIGTERM, shutting down gracefully...')
+  statsManager.shutdown()
+})
+
+export default WebSocketStats
+\ No newline at end of file
+diff --git a/packages/integrations/node/src/middleware/index.ts b/packages/integrations/node/src/middleware/index.ts
+new file mode 100644
+index 000000000..8e4f1b2a9
+--- /dev/null
++++ b/packages/integrations/node/src/middleware/index.ts
+@@ -0,0 +1,372 @@
+/**
+ * Enhanced middleware for Astro applications with automatic WebSocket tracking
+ * and integration. Provides WebSocket stats in Astro.locals.websocketStats.
+ */
+
+import type { MiddlewareHandler } from 'astro';
+import { WebSocketStats, logConnectionStats, type ConnectionStats } from '../websocket/stats.js';
+import { 
+  ConnectionManagerAPI, 
+  getConnectionManager, 
+  type ConnectionManagerConfig,
+  type ManagedConnection 
+} from '../websocket/connection-manager.js';
+
+/**
+ * Configuration options for the stats middleware
+ */
+export interface StatsMiddlewareConfig {
+  /** Whether to include detailed connection information (default: true) */
+  includeDetailedStats?: boolean;
+  /** Whether to include connection manager stats (default: true) */
+  includeManagerStats?: boolean;
+  /** Whether to include real-time connection count (default: true) */
+  includeConnectionCount?: boolean;
+  /** Whether to include connection IDs (default: false, for privacy) */
+  includeConnectionIds?: boolean;
+  /** Whether to include IP addresses in stats (default: false, for privacy) */
+  includeIPAddresses?: boolean;
+  /** Whether to include user agents (default: false, for privacy) */
+  includeUserAgents?: boolean;
+  /** Custom filter function for connections */
+  connectionFilter?: (connection: ManagedConnection) => boolean;
+  /** Whether to enable automatic logging (default: false in middleware) */
+  enableLogging?: boolean;
+  /** Log interval in milliseconds (default: 30000) */
+  logInterval?: number;
+  /** Whether to track page-specific connection counts (default: true) */
+  trackPageConnections?: boolean;
+  /** Whether to provide helper functions in locals (default: true) */
+  includeHelperFunctions?: boolean;
+}
+
+/**
+ * WebSocket stats interface available in Astro.locals
+ */
+export interface WebSocketStatsLocals {
+  /** Get current connection count */
+  getConnectionCount(): number;
+  /** Get detailed connection statistics */
+  getConnectionStats(): ConnectionStats;
+  /** Get connection manager statistics (if enabled) */
+  getManagerStats?(): ReturnType<typeof ConnectionManagerAPI.getStats>;
+  /** Get connections for current page/route (if page tracking enabled) */
+  getPageConnections?(): ManagedConnection[];
+  /** Get filtered connections based on middleware config */
+  getFilteredConnections(): any[];
+  /** Helper to check if WebSocket functionality is available */
+  isWebSocketEnabled(): boolean;
+  /** Helper to get connection count by status */
+  getConnectionsByStatus(): Record<string, number>;
+  /** Configuration used by this middleware instance */
+  config: Required<StatsMiddlewareConfig>;
+}
+
+/**
+ * Page connection tracking store
+ */
+const pageConnectionTracker = new Map<string, Set<string>>();
+
+/**
+ * Create enhanced middleware that provides automatic WebSocket tracking
+ * and integration with Astro applications
+ */
+export function createStatsMiddleware(config: StatsMiddlewareConfig = {}): MiddlewareHandler {
+  const middlewareConfig: Required<StatsMiddlewareConfig> = {
+    includeDetailedStats: config.includeDetailedStats ?? true,
+    includeManagerStats: config.includeManagerStats ?? true,
+    includeConnectionCount: config.includeConnectionCount ?? true,
+    includeConnectionIds: config.includeConnectionIds ?? false,
+    includeIPAddresses: config.includeIPAddresses ?? false,
+    includeUserAgents: config.includeUserAgents ?? false,
+    connectionFilter: config.connectionFilter ?? (() => true),
+    enableLogging: config.enableLogging ?? false,
+    logInterval: config.logInterval ?? 30000,
+    trackPageConnections: config.trackPageConnections ?? true,
+    includeHelperFunctions: config.includeHelperFunctions ?? true,
+  };
+
+  // Set up logging if enabled
+  let loggingInterval: NodeJS.Timeout | undefined;
+  if (middlewareConfig.enableLogging) {
+    loggingInterval = setInterval(() => {
+      logConnectionStats();
+    }, middlewareConfig.logInterval);
+  }
+
+  // Cleanup function for when the server shuts down
+  const cleanup = () => {
+    if (loggingInterval) {
+      clearInterval(loggingInterval);
+    }
+    pageConnectionTracker.clear();
+  };
+
+  // Handle process shutdown
+  process.once('SIGINT', cleanup);
+  process.once('SIGTERM', cleanup);
+
+  return async (context, next) => {
+    const { request, locals, url } = context;
+    
+    // Get current page/route identifier for tracking
+    const pageId = middlewareConfig.trackPageConnections ? 
+      `${url.pathname}${url.search}` : 'default';
+
+    // Create WebSocket stats locals object
+    const websocketStats: WebSocketStatsLocals = {
+      getConnectionCount(): number {
+        if (!middlewareConfig.includeConnectionCount) return 0;
+        return WebSocketStats.getConnectionCount();
+      },
+
+      getConnectionStats(): ConnectionStats {
+        const stats = WebSocketStats.getConnectionStats();
+        
+        if (!middlewareConfig.includeDetailedStats) {
+          // Return minimal stats
+          return {
+            ...stats,
+            connections: []
+          };
+        }
+
+        // Filter connections based on privacy settings
+        const filteredConnections = stats.connections.map(conn => ({
+          id: middlewareConfig.includeConnectionIds ? conn.id : '[hidden]',
+          age: conn.age,
+          idleTime: conn.idleTime,
+          state: conn.state,
+          remoteAddress: middlewareConfig.includeIPAddresses ? conn.remoteAddress : undefined,
+          userAgent: middlewareConfig.includeUserAgents ? conn.userAgent : undefined,
+        }));
+
+        return {
+          ...stats,
+          connections: filteredConnections
+        };
+      },
+
+      getFilteredConnections(): any[] {
+        try {
+          const manager = getConnectionManager();
+          const connections = manager.getAllManagedConnections();
+          const filtered = connections.filter(middlewareConfig.connectionFilter);
+          
+          return filtered.map(conn => ({
+            id: middlewareConfig.includeConnectionIds ? conn.id : '[hidden]',
+            age: conn.age,
+            idleTime: conn.idleTime,
+            state: conn.state,
+            healthStatus: conn.healthStatus,
+            priority: conn.priority,
+            tags: Array.from(conn.tags),
+            poolGroup: conn.poolGroup,
+            remoteAddress: middlewareConfig.includeIPAddresses ? conn.remoteAddress : undefined,
+            userAgent: middlewareConfig.includeUserAgents ? conn.userAgent : undefined,
+          }));
+        } catch (error) {
+          console.warn('Error getting filtered connections:', error);
+          return [];
+        }
+      },
+
+      isWebSocketEnabled(): boolean {
+        return !WebSocketStats.isShutDown;
+      },
+
+      getConnectionsByStatus(): Record<string, number> {
+        const stats = this.getConnectionStats();
+        return stats.connectionsByState;
+      },
+
+      config: middlewareConfig
+    };
+
+    // Add manager stats if enabled
+    if (middlewareConfig.includeManagerStats) {
+      websocketStats.getManagerStats = () => {
+        try {
+          return ConnectionManagerAPI.getStats();
+        } catch (error) {
+          console.warn('Error getting manager stats:', error);
+          return {
+            totalManagedConnections: 0,
+            connectionsByIP: 0,
+            rateLimitBuckets: 0,
+            healthStats: {},
+            poolStats: {},
+            idleConnections: 0,
+            config: {} as any,
+            isShutdown: true
+          };
+        }
+      };
+    }
+
+    // Add page connection tracking if enabled
+    if (middlewareConfig.trackPageConnections) {
+      websocketStats.getPageConnections = () => {
+        try {
+          const manager = getConnectionManager();
+          const pageConnections = pageConnectionTracker.get(pageId) || new Set();
+          
+          return Array.from(pageConnections)
+            .map(id => manager.getManagedConnection(id))
+            .filter((conn): conn is ManagedConnection => conn !== undefined)
+            .filter(middlewareConfig.connectionFilter);
+        } catch (error) {
+          console.warn('Error getting page connections:', error);
+          return [];
+        }
+      };
+    }
+
+    // Add to Astro.locals
+    locals.websocketStats = websocketStats;
+
+    // Proceed with the request
+    const response = await next();
+
+    // Track any new WebSocket connections that might have been created during this request
+    if (middlewareConfig.trackPageConnections && locals.isUpgradeRequest) {
+      // This would be called after a WebSocket upgrade
+      // We'll add a hook for this in the WebSocket attachment code
+      try {
+        const connectionIds = WebSocketStats.getConnectionIds();
+        if (!pageConnectionTracker.has(pageId)) {
+          pageConnectionTracker.set(pageId, new Set());
+        }
+        // Add the most recent connection (this is a best-effort approach)
+        const latestId = connectionIds[connectionIds.length - 1];
+        if (latestId) {
+          pageConnectionTracker.get(pageId)!.add(latestId);
+        }
+      } catch (error) {
+        console.warn('Error tracking page connection:', error);
+      }
+    }
+
+    return response;
+  };
+}
+
+/**
+ * Create middleware with connection manager integration
+ */
+export function createAdvancedStatsMiddleware(
+  config: StatsMiddlewareConfig = {},
+  managerConfig: ConnectionManagerConfig = {}
+): MiddlewareHandler {
+  // Initialize connection manager with provided config
+  getConnectionManager(managerConfig);
+  
+  return createStatsMiddleware({
+    includeManagerStats: true,
+    ...config
+  });
+}
+
+/**
+ * Create basic middleware with minimal configuration for production
+ */
+export function createBasicStatsMiddleware(): MiddlewareHandler {
+  return createStatsMiddleware({
+    includeDetailedStats: false,
+    includeConnectionIds: false,
+    includeIPAddresses: false,
+    includeUserAgents: false,
+    includeManagerStats: false,
+    trackPageConnections: false,
+    enableLogging: false
+  });
+}
+
+/**
+ * Create development middleware with full features enabled
+ */
+export function createDevStatsMiddleware(): MiddlewareHandler {
+  return createStatsMiddleware({
+    includeDetailedStats: true,
+    includeConnectionIds: true,
+    includeIPAddresses: true,
+    includeUserAgents: true,
+    includeManagerStats: true,
+    trackPageConnections: true,
+    enableLogging: true,
+    logInterval: 15000 // More frequent logging in dev
+  });
+}
+
+/**
+ * Utility function to add connection to page tracking
+ * This should be called from the WebSocket attachment code
+ */
+export function trackConnectionForPage(connectionId: string, pageId: string): void {
+  if (!pageConnectionTracker.has(pageId)) {
+    pageConnectionTracker.set(pageId, new Set());
+  }
+  pageConnectionTracker.get(pageId)!.add(connectionId);
+}
+
+/**
+ * Utility function to remove connection from page tracking
+ */
+export function untrackConnectionForPage(connectionId: string, pageId?: string): void {
+  if (pageId) {
+    const pageConnections = pageConnectionTracker.get(pageId);
+    if (pageConnections) {
+      pageConnections.delete(connectionId);
+      if (pageConnections.size === 0) {
+        pageConnectionTracker.delete(pageId);
+      }
+    }
+  } else {
+    // Remove from all pages
+    for (const [page, connections] of pageConnectionTracker.entries()) {
+      connections.delete(connectionId);
+      if (connections.size === 0) {
+        pageConnectionTracker.delete(page);
+      }
+    }
+  }
+}
+
+/**
+ * Get all tracked pages and their connection counts
+ */
+export function getPageConnectionCounts(): Record<string, number> {
+  const counts: Record<string, number> = {};
+  for (const [pageId, connections] of pageConnectionTracker.entries()) {
+    counts[pageId] = connections.size;
+  }
+  return counts;
+}
+
+/**
+ * Clear all page connection tracking
+ */
+export function clearPageTracking(): void {
+  pageConnectionTracker.clear();
+}
+
+// Export types for external use
+export type {
+  WithWebSocketStats,
+  APIContextWithWebSocketStats,
+  MiddlewareContextWithWebSocketStats
+} from './types.js';
+export { hasWebSocketStats } from './types.js';
+
+/**
+ * Type augmentation for Astro locals
+ */
+declare global {
+  namespace App {
+    interface Locals {
+      websocketStats?: WebSocketStatsLocals;
+    }
+  }
+}
+
+export default createStatsMiddleware;
+\ No newline at end of file
+diff --git a/packages/integrations/node/src/middleware/types.ts b/packages/integrations/node/src/middleware/types.ts
+new file mode 100644
+index 000000000..4e9c2b3a1
+--- /dev/null
++++ b/packages/integrations/node/src/middleware/types.ts
+@@ -0,0 +1,74 @@
+/**
+ * TypeScript type definitions for Astro.locals integration
+ * with WebSocket middleware functionality
+ */
+
+import type { WebSocketStatsLocals } from './index.js';
+
+// Import existing types to avoid conflicts
+import type { WebSocketUpgrade } from '../types.js';
+
+// Extend Astro's namespace with WebSocket functionality
+declare global {
+  namespace App {
+    interface Locals {
+      /**
+       * Enhanced WebSocket statistics and management functionality
+       * Available when using createStatsMiddleware() or similar middleware functions
+       */
+      websocketStats?: WebSocketStatsLocals;
+    }
+  }
+}
+
+/**
+ * Type helper for components that expect WebSocket stats to be available
+ */
+export type WithWebSocketStats<T = {}> = T & {
+  locals: {
+    websocketStats: WebSocketStatsLocals;
+  } & App.Locals;
+};
+
+/**
+ * Type guard to check if WebSocket stats are available
+ */
+export function hasWebSocketStats(locals: App.Locals): locals is App.Locals & { websocketStats: WebSocketStatsLocals } {
+  return locals.websocketStats !== undefined;
+}
+
+/**
+ * Type helper for API routes that use WebSocket stats
+ */
+export interface APIContextWithWebSocketStats {
+  locals: App.Locals & { 
+    websocketStats: WebSocketStatsLocals;
+  };
+  request: Request;
+  params: Record<string, string | undefined>;
+  url: URL;
+  clientAddress: string;
+  generator: string;
+  props: Record<string, any>;
+  redirect: (path: string, status?: number) => Response;
+  rewrite: (reroutePayload: string | URL | Request) => Promise<Response>;
+}
+
+/**
+ * Type for middleware context with WebSocket stats
+ */
+export interface MiddlewareContextWithWebSocketStats {
+  locals: App.Locals & { 
+    websocketStats: WebSocketStatsLocals;
+  };
+  request: Request;
+  url: URL;
+  params: Record<string, string | undefined>;
+  clientAddress: string;
+  generator: string;
+  props: Record<string, any>;
+  redirect: (path: string, status?: number) => Response;
+  rewrite: (reroutePayload: string | URL | Request) => Promise<Response>;
+}
+
+export {}; // Make this a module
+\ No newline at end of file
+diff --git a/packages/integrations/node/package.json b/packages/integrations/node/package.json
+index 39a993467..af3d3d5fc 100644
+--- a/packages/integrations/node/package.json
++++ b/packages/integrations/node/package.json
+@@ -18,9 +18,38 @@
+   "bugs": "https://github.com/withastro/astro/issues",
+   "homepage": "https://docs.astro.build/en/guides/integrations-guide/node/",
+   "exports": {
+-    ".": "./dist/index.js",
+-    "./server.js": "./dist/server.js",
+-    "./preview.js": "./dist/preview.js",
++    ".": {
++      "types": "./dist/index.d.ts",
++      "import": "./dist/index.js"
++    },
++    "./adapter": {
++      "types": "./dist/adapter/index.d.ts",
++      "import": "./dist/adapter/index.js"
++    },
++    "./server": {
++      "types": "./dist/adapter/server.d.ts",
++      "import": "./dist/adapter/server.js"
++    },
++    "./preview": {
++      "types": "./dist/adapter/preview.d.ts",
++      "import": "./dist/adapter/preview.js"
++    },
++    "./websocket/stats": {
++      "types": "./dist/websocket/stats.d.ts",
++      "import": "./dist/websocket/stats.js"
++    },
++    "./stats": {
++      "types": "./dist/websocket/stats.d.ts",
++      "import": "./dist/websocket/stats.js"
++    },
++    "./websocket/connection-manager": {
++      "types": "./dist/websocket/connection-manager.d.ts",
++      "import": "./dist/websocket/connection-manager.js"
++    },
++    "./connection-manager": {
++      "types": "./dist/websocket/connection-manager.d.ts",
++      "import": "./dist/websocket/connection-manager.js"
++    },
++    "./middleware": {
++      "types": "./dist/middleware/index.d.ts",
++      "import": "./dist/middleware/index.js"
++    },
+     "./package.json": "./package.json"
+   },
+   "files": [
