diff --git a/packages/integrations/cloudflare/package.json b/packages/integrations/cloudflare/package.json
index 2b4c3e560..4ffdb53a9 100644
--- a/packages/integrations/cloudflare/package.json
+++ b/packages/integrations/cloudflare/package.json
@@ -24,6 +24,7 @@
     "./image-service": "./dist/entrypoints/image-service.js",
     "./image-endpoint": "./dist/entrypoints/image-endpoint.js",
     "./handler": "./dist/utils/handler.js",
+    "./websocket": "./dist/websocket/index.js",
     "./package.json": "./package.json"
   },
   "files": [
diff --git a/packages/integrations/cloudflare/src/websocket/index.ts b/packages/integrations/cloudflare/src/websocket/index.ts
new file mode 100644
index 000000000..7c4e0c5c2
--- /dev/null
+++ b/packages/integrations/cloudflare/src/websocket/index.ts
@@ -0,0 +1,5 @@
+/**
+ * Cloudflare WebSocket exports
+ */
+
+export { WebSocket, attach, ErrorEvent, CloseEvent } from './websocket.js'
+export { onRequest } from './middleware.js'
+export { createWebSocketHandler } from './server.js'
diff --git a/packages/integrations/cloudflare/src/websocket/middleware.ts b/packages/integrations/cloudflare/src/websocket/middleware.ts
new file mode 100644
index 000000000..b4a4e9c0c
--- /dev/null
+++ b/packages/integrations/cloudflare/src/websocket/middleware.ts
@@ -0,0 +1,84 @@
+/**
+ * Cloudflare WebSocket middleware
+ */
+
+import { WebSocket, attach } from './websocket.js'
+
+export interface CloudflareLocals {
+  isUpgradeRequest: boolean
+  upgradeWebSocket(): { socket: WebSocket, response: Response }
+  runtime?: {
+    env: any
+    cf: any
+    ctx: any
+    caches: any
+    waitUntil: (promise: Promise<any>) => void
+  }
+}
+
+export const onRequest = async function cloudflareWebSocketMiddleware(
+  context: any,
+  next: () => Promise<Response>
+): Promise<Response> {
+  const { request, locals } = context
+
+  // Check if this is a WebSocket upgrade request
+  const isUpgradeRequest =
+    request.headers.get('upgrade') === 'websocket' &&
+    request.headers.get('connection')?.toLowerCase().includes('upgrade')
+
+  // Set up locals for WebSocket support
+  locals.isUpgradeRequest = isUpgradeRequest
+  locals.upgradeWebSocket = () => {
+    if (!isUpgradeRequest) {
+      throw new Error('The request must be an upgrade request to upgrade the connection to a WebSocket.')
+    }
+
+    // Create WebSocket pair for Cloudflare
+    const webSocketPair = new WebSocketPair()
+    const [client, server] = Object.values(webSocketPair)
+
+    // Create our WebSocket wrapper
+    const socket = new WebSocket(request.url)
+
+    // Attach the server-side WebSocket to our wrapper
+    attach(socket, server)
+
+    // Return WebSocket upgrade response
+    const response = new Response(null, {
+      status: 101,
+      statusText: 'Switching Protocols',
+      headers: {
+        'Upgrade': 'websocket',
+        'Connection': 'Upgrade',
+      },
+      // @ts-expect-error Cloudflare specific WebSocket property
+      webSocket: client,
+    })
+
+    return { socket, response }
+  }
+
+  return next()
+}
+
+// Add WebSocket types for Cloudflare
+declare global {
+  interface WebSocketPair {
+    0: CloudflareWebSocket
+    1: CloudflareWebSocket
+  }
+
+  var WebSocketPair: {
+    new (): WebSocketPair
+  }
+
+  interface CloudflareWebSocket {
+    send(data: string | ArrayBufferLike | ArrayBufferView): void
+    close(code?: number, reason?: string): void
+    addEventListener(type: 'message', listener: (event: { data: any }) => void): void
+    addEventListener(type: 'close', listener: (event: { code: number; reason: string; wasClean: boolean }) => void): void
+    addEventListener(type: 'error', listener: (event: any) => void): void
+    accept(): void
+  }
+}
diff --git a/packages/integrations/cloudflare/src/websocket/server.ts b/packages/integrations/cloudflare/src/websocket/server.ts
new file mode 100644
index 000000000..3e5b5ae7e
--- /dev/null
+++ b/packages/integrations/cloudflare/src/websocket/server.ts
@@ -0,0 +1,102 @@
+/**
+ * Cloudflare WebSocket server entrypoint
+ */
+
+import type { CloudflareApp } from '../utils/handler.js'
+import { WebSocket, attach } from './websocket.js'
+
+export function createWebSocketHandler(app: CloudflareApp) {
+  return async function handleWebSocket(request: Request, env: any, ctx: any) {
+    // Check if this is a WebSocket upgrade request
+    const upgradeHeader = request.headers.get('upgrade')
+    const connectionHeader = request.headers.get('connection')
+
+    if (upgradeHeader !== 'websocket' || !connectionHeader?.toLowerCase().includes('upgrade')) {
+      // Not a WebSocket upgrade request, handle normally
+      return app.render(request, { locals: { isUpgradeRequest: false } })
+    }
+
+    // Create WebSocket pair for Cloudflare
+    const webSocketPair = new WebSocketPair()
+    const [client, server] = Object.values(webSocketPair)
+
+    // Render the Astro page with WebSocket support
+    const response = await app.render(request, {
+      locals: {
+        isUpgradeRequest: true,
+        upgradeWebSocket() {
+          // Create our WebSocket wrapper
+          const socket = new WebSocket(request.url)
+
+          // Attach the server-side WebSocket to our wrapper
+          attach(socket, server)
+
+          // Return WebSocket upgrade response
+          const upgradeResponse = new Response(null, {
+            status: 101,
+            statusText: 'Switching Protocols',
+            headers: {
+              'Upgrade': 'websocket',
+              'Connection': 'Upgrade',
+            },
+            // @ts-expect-error Cloudflare specific WebSocket property
+            webSocket: client,
+          })
+
+          return { socket, response: upgradeResponse }
+        },
+        runtime: {
+          env,
+          cf: request.cf,
+          ctx,
+          caches: (globalThis as any).caches,
+          waitUntil: (promise: Promise<any>) => ctx.waitUntil(promise),
+        },
+      },
+    })
+
+    // If the response is a WebSocket upgrade response, accept the connection
+    if (response.status === 101 && response.headers.get('upgrade') === 'websocket') {
+      // Accept the WebSocket connection
+      server.accept()
+
+      // Return the response with the client WebSocket
+      return new Response(null, {
+        status: 101,
+        statusText: 'Switching Protocols',
+        headers: {
+          'Upgrade': 'websocket',
+          'Connection': 'Upgrade',
+        },
+        // @ts-expect-error Cloudflare specific WebSocket property
+        webSocket: client,
+      })
+    }
+
+    return response
+  }
+}
+
+// Re-export WebSocket types for convenience
+export { WebSocket, attach } from './websocket.js'
+
+// Add WebSocket types for Cloudflare
+declare global {
+  interface WebSocketPair {
+    0: CloudflareWebSocket
+    1: CloudflareWebSocket
+  }
+
+  var WebSocketPair: {
+    new (): WebSocketPair
+  }
+
+  interface CloudflareWebSocket {
+    send(data: string | ArrayBufferLike | ArrayBufferView): void
+    close(code?: number, reason?: string): void
+    addEventListener(type: 'message', listener: (event: { data: any }) => void): void
+    addEventListener(type: 'close', listener: (event: { code: number; reason: string; wasClean: boolean }) => void): void
+    addEventListener(type: 'error', listener: (event: any) => void): void
+    accept(): void
+  }
+}
diff --git a/packages/integrations/cloudflare/src/websocket/websocket.ts b/packages/integrations/cloudflare/src/websocket/websocket.ts
new file mode 100644
index 000000000..b9deb1a14
--- /dev/null
+++ b/packages/integrations/cloudflare/src/websocket/websocket.ts
@@ -0,0 +1,199 @@
+/**
+ * Cloudflare WebSocket implementation
+ */
+
+type WebSocketInterface = globalThis.WebSocket
+
+export interface WebSocketUpgrade {
+  socket: WebSocket
+  response: Response
+}
+
+export class WebSocket extends EventTarget implements WebSocketInterface {
+  private _ws: CloudflareWebSocket | undefined
+  private _readyState: number = WebSocket.CONNECTING
+  private _binaryType: 'blob' | 'arraybuffer' = 'blob'
+  private _url: string = ''
+  private _protocol: string = ''
+  private _extensions: string = ''
+  private _bufferedAmount: number = 0
+
+  static readonly CONNECTING = 0 as const
+  static readonly OPEN       = 1 as const
+  static readonly CLOSING    = 2 as const
+  static readonly CLOSED     = 3 as const
+
+  // Instance constants
+  declare readonly CONNECTING: 0
+  declare readonly OPEN      : 1
+  declare readonly CLOSING   : 2
+  declare readonly CLOSED    : 3
+
+  // Event handlers
+  onopen : WebSocketInterface["onopen"]  = null
+  onerror: WebSocketInterface["onerror"] = null
+  onclose: WebSocketInterface["onclose"] = null
+  onmessage : WebSocketInterface["onmessage"] = null
+
+  constructor(url?: string) {
+    super()
+    this._url = url || ''
+  }
+
+  get url() {
+    return this._url
+  }
+
+  get readyState() {
+    return this._readyState
+  }
+
+  get bufferedAmount() {
+    return this._bufferedAmount
+  }
+
+  get extensions() {
+    return this._extensions
+  }
+
+  get protocol() {
+    return this._protocol
+  }
+
+  get binaryType() {
+    return this._binaryType
+  }
+
+  set binaryType(value: 'blob' | 'arraybuffer') {
+    this._binaryType = value
+  }
+
+  close(code?: number, reason?: string) {
+    if (this._readyState === WebSocket.CLOSED || this._readyState === WebSocket.CLOSING) {
+      return
+    }
+
+    this._readyState = WebSocket.CLOSING
+
+    if (this._ws) {
+      this._ws.close(code, reason)
+    } else {
+      // Close immediately if not attached
+      this._readyState = WebSocket.CLOSED
+      const event = new CloseEvent('close', { code: code || 1000, reason: reason || '', wasClean: true })
+      this.onclose?.(event)
+      this.dispatchEvent(event)
+    }
+  }
+
+  send(data: string | ArrayBufferLike | Blob | ArrayBufferView) {
+    if (this._readyState !== WebSocket.OPEN) {
+      throw new Error('WebSocket is not open')
+    }
+
+    if (this._ws) {
+      if (data instanceof Blob) {
+        // Convert blob to array buffer for Cloudflare
+        data.arrayBuffer().then(buffer => this._ws!.send(buffer))
+      } else {
+        this._ws.send(data)
+      }
+    }
+  }
+
+  static {
+    Object.assign(this.prototype, {
+      CONNECTING: 0,
+      OPEN      : 1,
+      CLOSING   : 2,
+      CLOSED    : 3
+    })
+
+    // Freeze the prototype and class to align with the spec
+    Object.freeze(this.prototype)
+    Object.freeze(this)
+  }
+}
+
+// WeakMap to store private Cloudflare WebSocket instances
+const wsMap = new WeakMap<WebSocket, CloudflareWebSocket>()
+
+export function attach(standard: WebSocket, cfWebSocket: CloudflareWebSocket): void {
+  if (wsMap.has(standard)) {
+    throw new Error('WebSocket already attached')
+  }
+
+  wsMap.set(standard, cfWebSocket)
+  ;(standard as any)._ws = cfWebSocket
+  ;(standard as any)._readyState = WebSocket.OPEN
+
+  // Set up event forwarding
+  cfWebSocket.addEventListener('message', (event) => {
+    const messageEvent = new MessageEvent('message', { data: event.data })
+    standard.onmessage?.(messageEvent)
+    standard.dispatchEvent(messageEvent)
+  })
+
+  cfWebSocket.addEventListener('close', (event) => {
+    ;(standard as any)._readyState = WebSocket.CLOSED
+    const closeEvent = new CloseEvent('close', {
+      code: event.code,
+      reason: event.reason,
+      wasClean: event.wasClean
+    })
+    standard.onclose?.(closeEvent)
+    standard.dispatchEvent(closeEvent)
+  })
+
+  cfWebSocket.addEventListener('error', (event) => {
+    const errorEvent = new ErrorEvent('error', { message: 'WebSocket error' })
+    standard.onerror?.(errorEvent)
+    standard.dispatchEvent(errorEvent)
+  })
+
+  // Dispatch open event
+  const openEvent = new Event('open')
+  standard.onopen?.(openEvent)
+  standard.dispatchEvent(openEvent)
+}
+
+export class ErrorEvent extends Event {
+  constructor(type: string, init?: { message?: string }) {
+    super(type)
+    this.message = init?.message || ''
+  }
+
+  readonly message: string
+}
+
+export class CloseEvent extends Event implements globalThis.CloseEvent {
+  readonly code: number
+  readonly reason: string
+  readonly wasClean: boolean
+
+  constructor(type: string, eventInitDict?: CloseEventInit) {
+    super(type, eventInitDict)
+    this.code = eventInitDict?.code ?? 0
+    this.reason = eventInitDict?.reason ?? ''
+    this.wasClean = eventInitDict?.wasClean ?? false
+  }
+}
+
+interface CloseEventInit extends EventInit {
+  code?: number
+  reason?: string
+  wasClean?: boolean
+}
+
+// Cloudflare WebSocket types
+interface CloudflareWebSocket {
+  send(data: string | ArrayBufferLike | ArrayBufferView): void
+  close(code?: number, reason?: string): void
+  addEventListener(type: 'message', listener: (event: { data: any }) => void): void
+  addEventListener(type: 'close', listener: (event: { code: number; reason: string; wasClean: boolean }) => void): void
+  addEventListener(type: 'error', listener: (event: any) => void): void
+  addEventListener(type: 'open', listener: (event: any) => void): void
+  removeEventListener(type: string, listener: any): void
+  readonly readyState: number
+  readonly url: string
+}
